import itertools


class HypothesisSpace:

    def __init__(self, hypotheses=None):
        self.hypotheses = hypotheses if hypotheses is not None else []

    def isEmpty(self):
        """
        Supporting function for ComplexListener
        """
        return True if self.hypotheses == [] else False

    def InsertHypothesis(self, hypothesis):
        """
        Add a new hypothesis.
        """
        self.hypotheses.append(hypothesis)

    def AddTrial(self, index, utterance, probability):
        """
        Add an utterance and probability. This function just pipes
        the command into the hypothesis object.
        """
        self.hypotheses[index].AddTrial(utterance, probability)

    def ComputeVWPosterior(self, VWs):
        """
        Compute the posterior distribution over visual worlds.

        Args:
        VWs: hypothesis space as a list of VisualWorld objects.
        This hypothesis space is generated by running
        SF.BuildVWHypothesisSpace and taking the first argument.
        """
        # To do this you need to integrate over the space of possible
        # referents.
        VisualWorlds = []
        Beliefs = []
        for VisualWorldHypothesis in VWs:
            # extract the hypothese that apply to this visual world
            Fullrelevant = self.PullVW(VisualWorldHypothesis.GetIDs())
            # Iterate over each subset with different speaker biases
            Fullprob = 0
            for relevant in Fullrelevant:
                # now build the space of all possible referent vectors
                # Build a list with the indices of how to navigate
                BaseIndices = [range(len(relevant))
                               for i in range(len(relevant[0].Likelihood))]
                IndexNavigations = list(itertools.product(*BaseIndices))
                prob = 0
                for i in range(len(IndexNavigations)):
                    likelihood = 1
                    for j in range(len(IndexNavigations[i])):
                        likelihood *= relevant[IndexNavigations[i]
                                               [j]].Likelihood[j]
                    prob += likelihood
                # now add the prior. Since all hypotheses refer to the same visual world, the
                # prior is the same. So just use any.
                prob *= relevant[0].VWprior*relevant[0].SBprior
                Fullprob += prob
            VisualWorlds.append(VisualWorldHypothesis.GetIDs())
            Beliefs.append(Fullprob)
        return[VisualWorlds, Beliefs]

    def ComputeBiasPosterior(self):
        """
        Compute the posterior over speaker biases.
        """

    def ComputeReferentPosterior(self, Refs):
        """
        Compute the posterior over referent vectors.
        Args:
        Refs (list of referent IDs)
        """
        # The hypothesis space consists of all vectors of referents.

        # for Referent in Refs:
        # Extract hypotheses that matter
        #    relevant = self.PullRefs(Referent)

    def PullRefs(self, Referent):
        """
        Retrieve all hypotheses that have the target referent,
        split by 
        Referent (target referent ID)
        """
        Returnset = []
        for hypothesis in self.hypotheses:
            if hypothesis.ReferentID == Referent:
                Returnset.append(hypothesis)
        return Returnset

    def PullVW(self, VW):
        """
        Retrieve all hypotheses with a given visual world, split by speaker bias objects.
        VW (List of object names; should be retrieved from VisualWorld.GetIDs())
        """
        Returnset = []
        for hypothesis in self.hypotheses:
            if hypothesis.VisualWorldIDs == VW:
                Returnset.append(hypothesis)
        # Now split Returnset based on the SpeakerBiases.
        # First create the space of speaker biases in the return set.
        SpeakerBiasSet = []
        for hypothesis in Returnset:
            if hypothesis.SpeakerBiases not in SpeakerBiasSet:
                SpeakerBiasSet.append(hypothesis.SpeakerBiases)
        # Now create the final return set.
        FinalReturnSet = []
        for SpeakerBias in SpeakerBiasSet:
            Hypothesissubset = []
            for hypothesis in Returnset:
                if hypothesis.SpeakerBiases == SpeakerBias:
                    Hypothesissubset.append(hypothesis)
            FinalReturnSet.append(Hypothesissubset)
        return FinalReturnSet
